import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as n,d as a}from"./app-jr09F59J.js";const i={},l=a(`<h1 id="js事件循环机制" tabindex="-1"><a class="header-anchor" href="#js事件循环机制"><span>JS事件循环机制</span></a></h1><blockquote><p>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</p></blockquote><h3 id="首先我们要知道两点" tabindex="-1"><a class="header-anchor" href="#首先我们要知道两点"><span>首先我们要知道两点：</span></a></h3><ul><li>JavaScript 是单线程的语言</li><li>Event Loop 是 javascript 的执行机制</li></ul><h3 id="javascript-事件循环" tabindex="-1"><a class="header-anchor" href="#javascript-事件循环"><span>javascript 事件循环</span></a></h3><p>js 是单线程，就像学生排队上厕所，学生需要排队一个一个上厕所，同理 js 任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa38dcffce~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从图片可知，一个方法执行会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，其结果不过是在执行栈中再添加一个执行环境。这个过程可以是无限进行下去的，除非发生了栈溢出，即超过了所能使用内存的最大值。</p><p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制</p><h5 id="先看一段代码" tabindex="-1"><a class="header-anchor" href="#先看一段代码"><span>先看一段代码：</span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>console.log(&#39;script start&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(function() {</span></span>
<span class="line"><span>  console.log(&#39;setTimeout&#39;);</span></span>
<span class="line"><span>}, 0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Promise.resolve().then(function() {</span></span>
<span class="line"><span>  console.log(&#39;promise1&#39;);</span></span>
<span class="line"><span>}).then(function() {</span></span>
<span class="line"><span>  console.log(&#39;promise2&#39;);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(&#39;script end&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打印顺序是什么？ 正确答案是：script start, script end, promise1, promise2, setTimeout 已蒙圈。。。</p><h3 id="为什么会出现这样打印顺序呢" tabindex="-1"><a class="header-anchor" href="#为什么会出现这样打印顺序呢"><span>为什么会出现这样打印顺序呢？</span></a></h3><ul><li>如下导图（此图从网站下载）</li></ul><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fb89da87c5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>解读：</p><ul><li>同步和异步任务分别进入不同的执行 &quot;场所&quot;，同步的进入主线程，异步的进入 Event Table 并注册函数</li><li>当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。</li><li>主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的 Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空呢？js 引擎存在 monitoring process 进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数。</p><p>看代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let data = [];</span></span>
<span class="line"><span>$.ajax({</span></span>
<span class="line"><span>    url:www.javascript.com,</span></span>
<span class="line"><span>    data:data,</span></span>
<span class="line"><span>    success:() =&gt; {</span></span>
<span class="line"><span>        console.log(&#39;发送成功!&#39;);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>console.log(&#39;代码执行结束&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一段简易的 ajax 请求代码：</p><ul><li>ajax 进入 Event Table，注册回调函数 success。</li><li>执行 console.log(&#39;代码执行结束&#39;)。</li><li>ajax 事件完成，回调函数 success 进入 Event Queue。</li><li>主线程从 Event Queue 读取回调函数 success 并执行。</li></ul><p>相信通过上面的文字和代码，你已经对 js 的执行顺序有了初步了解。</p><h3 id="微任务-microtasks-、宏任务-task" tabindex="-1"><a class="header-anchor" href="#微任务-microtasks-、宏任务-task"><span>微任务 (Microtasks)、宏任务 (task)？</span></a></h3><h5 id="微任务和宏任务皆为异步任务-它们都属于一个队列-主要区别在于他们的执行顺序-event-loop-的走向和取值。那么他们之间到底有什么区别呢" tabindex="-1"><a class="header-anchor" href="#微任务和宏任务皆为异步任务-它们都属于一个队列-主要区别在于他们的执行顺序-event-loop-的走向和取值。那么他们之间到底有什么区别呢"><span>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序，Event Loop 的走向和取值。那么他们之间到底有什么区别呢？</span></a></h5><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa4b42e4af~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要： 那么如此看来我给的答案还是对的。但是 js 异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入 eventqueue，然后在执行微任务，将微任务放入 eventqueue 最骚的是，这两个 queue 不是一个 queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的 queue 上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><ul><li>而宏任务一般是：包括整体代码 script，setTimeout，setInterval、setImmediate。</li><li>微任务：原生 Promise(有些实现的 promise 将 then 方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver 记住就行了。</li><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fprocess.html" title="http://nodejs.cn/api/process.html" target="_blank" rel="noopener noreferrer">process 是什么？</a></li></ul><p>不废话，看以下例子：</p><h3 id="settimeout" tabindex="-1"><a class="header-anchor" href="#settimeout"><span>setTimeout</span></a></h3><p>大名鼎鼎的 setTimeout 无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时 3 秒执行：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>    console.log(&#39;延时3秒&#39;);</span></span>
<span class="line"><span>},3000)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>渐渐的 setTimeout 用的地方多了，问题也出现了，有时候明明写的延时 3 秒，实际却 5，6 秒才执行函数，这又咋回事啊？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>    task();</span></span>
<span class="line"><span>},3000)</span></span>
<span class="line"><span>console.log(&#39;执行console&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据前面我们的结论，setTimeout 是异步的，应该先执行 console.log 这个同步任务，所以我们的结论是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 执行console</span></span>
<span class="line"><span>// task()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>    task()</span></span>
<span class="line"><span>},3000)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>sleep(10000000)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看其实差不多嘛，但我们把这段代码在 chrome 执行一下，却发现控制台执行 task() 需要的时间远远超过 3 秒，说好的延时三秒，为啥现在需要这么长时间啊？ 这时候我们需要重新理解<code>setTimeout</code>的定义。我们先说上述代码是怎么执行的：</p><ul><li>task() 进入 Event Table 并注册, 计时开始。</li><li>执行 sleep 函数，很慢，非常慢，计时仍在继续。</li><li>3 秒到了，计时事件 timeout 完成，task() 进入 Event Queue，但是 sleep 也太慢了吧，还没执行完，只好等着。</li><li>sleep 终于执行完了，task() 终于从 Event Queue 进入了主线程执行。</li></ul><p>上述的流程走完，我们知道 setTimeout 这个函数，是经过指定时间后，把要执行的任务 (本例中为 task()) 加入到 Event Queue 中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于 3 秒。</p><p>我们还经常遇到<code>setTimeout(fn,0)</code>这样的代码，0 秒后执行又是什么意思呢？是不是可以立即执行呢？ 答案是不会的，<code>setTimeout(fn,0)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//代码1</span></span>
<span class="line"><span>console.log(&#39;先执行这里&#39;);</span></span>
<span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>    console.log(&#39;执行啦&#39;)</span></span>
<span class="line"><span>},0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>//代码2</span></span>
<span class="line"><span>console.log(&#39;先执行这里&#39;);</span></span>
<span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>    console.log(&#39;执行啦&#39;)</span></span>
<span class="line"><span>},3000);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码 1 的输出结果是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>先执行这里</span></span>
<span class="line"><span>执行啦</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>代码 2 的输出结果是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>//先执行这里</span></span>
<span class="line"><span>// ... 3s later</span></span>
<span class="line"><span>// 执行啦</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于 setTimeout 要补充的是，即便主线程为空，0 毫秒实际上也是达不到的。根据 HTML 的标准，最低是 4 毫秒。有兴趣的同学可以自行了解。</p><h3 id="setinterval" tabindex="-1"><a class="header-anchor" href="#setinterval"><span>setInterval</span></a></h3><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入 Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，<code>对于setInterval(fn,ms)</code>来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p><h3 id="promise-与-process-nexttick-callback" tabindex="-1"><a class="header-anchor" href="#promise-与-process-nexttick-callback"><span>Promise 与 process.nextTick(callback)</span></a></h3><ul><li>Promise 的定义和功能本文不再赘述，可以学习一下 <a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise" title="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener noreferrer">阮一峰老师的 Promise</a></li><li>而 process.nextTick(callback) 类似 node.js 版的 &quot;setTimeout&quot;，在事件循环的下一次循环中调用 callback 回调函数。</li></ul><h5 id="不同类型的任务会进入对应的-event-queue-比如settimeout和setinterval会进入相同的-event-queue。" tabindex="-1"><a class="header-anchor" href="#不同类型的任务会进入对应的-event-queue-比如settimeout和setinterval会进入相同的-event-queue。"><span>不同类型的任务会进入对应的 Event Queue，比如<code>setTimeout</code>和<code>setInterval</code>会进入相同的 Event Queue。</span></a></h5><p>看例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>setTimeout(()=&gt;{</span></span>
<span class="line"><span>  console.log(&#39;setTimeout1&#39;)</span></span>
<span class="line"><span>},0)</span></span>
<span class="line"><span>let p = new Promise((resolve,reject)=&gt;{</span></span>
<span class="line"><span>  console.log(&#39;Promise1&#39;)</span></span>
<span class="line"><span>  resolve()</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>p.then(()=&gt;{</span></span>
<span class="line"><span>  console.log(&#39;Promise2&#39;)    </span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="最后输出结果是-promise1-promise2-settimeout1" tabindex="-1"><a class="header-anchor" href="#最后输出结果是-promise1-promise2-settimeout1"><span>最后输出结果是 Promise1，Promise2，setTimeout1</span></a></h5><p>Promise 参数中的 Promise1 是同步执行的 其次是因为 Promise 是 microtasks，会在同步任务执行完后会去清空 microtasks queues， 最后清空完微任务再去宏任务队列取值。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Promise.resolve().then(()=&gt;{</span></span>
<span class="line"><span>  console.log(&#39;Promise1&#39;)  </span></span>
<span class="line"><span>  setTimeout(()=&gt;{</span></span>
<span class="line"><span>    console.log(&#39;setTimeout2&#39;)</span></span>
<span class="line"><span>  },0)</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(()=&gt;{</span></span>
<span class="line"><span>  console.log(&#39;setTimeout1&#39;)</span></span>
<span class="line"><span>  Promise.resolve().then(()=&gt;{</span></span>
<span class="line"><span>    console.log(&#39;Promise2&#39;)    </span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>},0)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="这回是嵌套-大家可以看看-最后输出结果是-promise1-settimeout1-promise2-settimeout2" tabindex="-1"><a class="header-anchor" href="#这回是嵌套-大家可以看看-最后输出结果是-promise1-settimeout1-promise2-settimeout2"><span>这回是嵌套，大家可以看看，最后输出结果是 Promise1，setTimeout1，Promise2，setTimeout2</span></a></h5><ul><li>一开始执行栈的同步任务执行完毕，会去 microtasks queues 找 清空 microtasks queues ，输出<code>Promise1</code>，同时会生成一个异步任务 setTimeout1</li><li>去宏任务队列查看此时队列是 setTimeout1 在 setTimeout2 之前，因为 setTimeout1 执行栈一开始的时候就开始异步执行, 所以输出 <code>setTimeout1</code></li><li>在执行 setTimeout1 时会生成 Promise2 的一个 microtasks ，放入 microtasks queues 中，接着又是一个循环，去清空 microtasks queues ，输出 <code>Promise2</code></li><li>清空完 microtasks queues ，就又会去宏任务队列取一个，这回取的是 <code>setTimeout2</code></li></ul><p>如下图：</p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/1649751a2eb3953f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最后我们来分析一段较复杂的代码，看看你是否真的掌握了 js 的执行机制：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>console.log(&#39;1&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(function() {</span></span>
<span class="line"><span>    console.log(&#39;2&#39;);</span></span>
<span class="line"><span>    process.nextTick(function() {</span></span>
<span class="line"><span>        console.log(&#39;3&#39;);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    new Promise(function(resolve) {</span></span>
<span class="line"><span>        console.log(&#39;4&#39;);</span></span>
<span class="line"><span>        resolve();</span></span>
<span class="line"><span>    }).then(function() {</span></span>
<span class="line"><span>        console.log(&#39;5&#39;)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>process.nextTick(function() {</span></span>
<span class="line"><span>    console.log(&#39;6&#39;);</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>new Promise(function(resolve) {</span></span>
<span class="line"><span>    console.log(&#39;7&#39;);</span></span>
<span class="line"><span>    resolve();</span></span>
<span class="line"><span>}).then(function() {</span></span>
<span class="line"><span>    console.log(&#39;8&#39;)</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(function() {</span></span>
<span class="line"><span>    console.log(&#39;9&#39;);</span></span>
<span class="line"><span>    process.nextTick(function() {</span></span>
<span class="line"><span>        console.log(&#39;10&#39;);</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    new Promise(function(resolve) {</span></span>
<span class="line"><span>        console.log(&#39;11&#39;);</span></span>
<span class="line"><span>        resolve();</span></span>
<span class="line"><span>    }).then(function() {</span></span>
<span class="line"><span>        console.log(&#39;12&#39;)</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一轮事件循环流程分析如下：</p><ul><li>整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出<code>1</code>。</li><li>遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到 process.nextTick()，其回调函数被分发到微任务 Event Queue 中。我们记为<code>process1</code>。</li><li>遇到 Promise，new Promise 直接执行，输出 7。then 被分发到微任务 Event Queue 中。我们记为<code>then1</code>。</li><li>又遇到了 setTimeout，其回调函数被分发到宏任务 Event Queue 中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各 Event Queue 的情况，此时已经输出了<code>1</code>和<code>7</code>。</li></ul><p>我们发现了 process1 和 then1 两个微任务。</p><ul><li>执行 process1, 输出<code>6</code>。</li><li>执行 then1，输出<code>8</code>。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出<code>1，7，6，8</code>。那么第二轮时间循环从 setTimeout1 宏任务开始：</p><ul><li>首先输出<code>2</code>。接下来遇到了 process.nextTick()，同样将其分发到微任务 Event Queue 中，记为 process2。</li><li>new Promise 立即执行输出<code>4</code>，then 也分发到微任务 Event Queue 中，记为 then2</li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li><p>第三轮事件循环宏任务执行结束，执行两个微任务 process3 和 then3。</p></li><li><p>输出<code>10</code>。</p></li><li><p>输出<code>12</code>。</p></li><li><p>第三轮事件循环结束，第三轮输出<code>9，11，10，12</code>。</p></li><li><p>整段代码，共进行了三次事件循环，完整的输出为<code>1，7，6，8，2，4，3，5，9，11，10，12</code>。(请注意，node 环境下的事件监听依赖 libuv 与前端环境不完全相同，输出顺序可能会有误差)</p></li></ul><h3 id="结尾" tabindex="-1"><a class="header-anchor" href="#结尾"><span>结尾</span></a></h3><p>希望大家看了本篇文章都有收获 ...</p><h4 id="好了-最后希望大家世界杯都能够逢赌必赢-自己喜欢的球队也能够杀进决赛" tabindex="-1"><a class="header-anchor" href="#好了-最后希望大家世界杯都能够逢赌必赢-自己喜欢的球队也能够杀进决赛"><span>好了，最后希望大家世界杯都能够逢赌必赢，自己喜欢的球队也能够杀进决赛！</span></a></h4>`,79),t=[l];function p(c,o){return n(),e("div",null,t)}const u=s(i,[["render",p],["__file","JS事件循环机制.html.vue"]]),m=JSON.parse('{"path":"/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.html","title":"JS事件循环机制","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2023-09-10T00:00:00.000Z","category":["面试"],"tag":["eventloop","事件循环","Javascript"],"description":"JS事件循环机制 [1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务...","head":[["meta",{"property":"og:url","content":"https://github.com/tommmmya/Tommya-Blog/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"Tommya 个人博客"}],["meta",{"property":"og:title","content":"JS事件循环机制"}],["meta",{"property":"og:description","content":"JS事件循环机制 [1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa38dcffce~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-29T07:56:04.000Z"}],["meta",{"property":"article:author","content":"Mr.Tommya"}],["meta",{"property":"article:tag","content":"eventloop"}],["meta",{"property":"article:tag","content":"事件循环"}],["meta",{"property":"article:tag","content":"Javascript"}],["meta",{"property":"article:published_time","content":"2023-09-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-29T07:56:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS事件循环机制\\",\\"image\\":[\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa38dcffce~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png\\",\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fb89da87c5~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png\\",\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/164974fa4b42e4af~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png\\",\\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/14/1649751a2eb3953f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png\\"],\\"datePublished\\":\\"2023-09-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-29T07:56:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Tommya\\",\\"url\\":\\"https://github.com/tommmmya\\"}]}"]]},"headers":[{"level":3,"title":"首先我们要知道两点：","slug":"首先我们要知道两点","link":"#首先我们要知道两点","children":[]},{"level":3,"title":"javascript 事件循环","slug":"javascript-事件循环","link":"#javascript-事件循环","children":[]},{"level":3,"title":"为什么会出现这样打印顺序呢？","slug":"为什么会出现这样打印顺序呢","link":"#为什么会出现这样打印顺序呢","children":[]},{"level":3,"title":"微任务 (Microtasks)、宏任务 (task)？","slug":"微任务-microtasks-、宏任务-task","link":"#微任务-microtasks-、宏任务-task","children":[]},{"level":3,"title":"setTimeout","slug":"settimeout","link":"#settimeout","children":[]},{"level":3,"title":"setInterval","slug":"setinterval","link":"#setinterval","children":[]},{"level":3,"title":"Promise 与 process.nextTick(callback)","slug":"promise-与-process-nexttick-callback","link":"#promise-与-process-nexttick-callback","children":[]},{"level":3,"title":"结尾","slug":"结尾","link":"#结尾","children":[]}],"git":{"createdTime":1728989573000,"updatedTime":1730188564000,"contributors":[{"name":"tangmao02","email":"tangmao02@meituan.com","commits":2}]},"readingTime":{"minutes":10.05,"words":3016},"filePathRelative":"study/2.深入必备/JS事件循环机制.md","localizedDate":"2023年9月10日","excerpt":"\\n<blockquote>\\n<p>[1] 本文主要根据网上资源总结而来，如有不对，请斧正。 [2] 需要知道的专业名词术语：synchronous：同步任务、asynchronous：异步任务、task queue/callback queue：任务队列、execution context stack：执行栈、heap：堆、stack：栈、macro-task：宏任务、micro-task：微任务</p>\\n</blockquote>\\n<h3>首先我们要知道两点：</h3>\\n<ul>\\n<li>JavaScript 是单线程的语言</li>\\n<li>Event Loop 是 javascript 的执行机制</li>\\n</ul>","autoDesc":true}');export{u as comp,m as data};
