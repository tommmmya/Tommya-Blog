import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as s,d as e}from"./app-jr09F59J.js";const i={},c=e(`<h1 id="深入理解watch和watcheffect的区别与应用-md" tabindex="-1"><a class="header-anchor" href="#深入理解watch和watcheffect的区别与应用-md"><span>深入理解watch和watchEffect的区别与应用.md</span></a></h1><p>======</p><p>在 Vue.js 中，除了可以使用<code>watch</code>方法监视数据变化，其实还有一种名为<code>watchEffect</code>的方法同样可以帮助我们监视数据变化并执行相应操作。对于<code>watch</code>和<code>watchEffect</code>两种方法来说，虽然它们功能上有着相似之处，但是它们之间有一些重要的区别。理解它们的不同之处对于有效地使用 Vue 3 来管理应用程序状态至关重要。</p><h2 id="watch" tabindex="-1"><a class="header-anchor" href="#watch"><span><code>watch</code></span></a></h2><p>对于<code>watch</code>方法，我们之前已经详细的介绍过了，这里不再过多赘述。</p><h4 id="watch-的基本用法" tabindex="-1"><a class="header-anchor" href="#watch-的基本用法"><span>watch 的基本用法</span></a></h4><p>当我们需要在数据变化时执行一些 “副作用”：如更改 DOM、执行异步操作，我们可以使用 <code>watch</code> 函数：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref, watch } from &#39;vue&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>watch(count, (newValue, oldValue) =&gt; {</span></span>
<span class="line"><span>  console.log(\`count 值从 \${oldValue} 变为 \${newValue}\`);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>  count.value++;</span></span>
<span class="line"><span>}, 1000);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用 <code>watch</code> 监视 <code>count</code> 的变化，并在值变化时打印出旧值和新值。</p><h2 id="watcheffect" tabindex="-1"><a class="header-anchor" href="#watcheffect"><span><code>watchEffect</code></span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p><code>watchEffect</code> 是 Vue 3 中的一个核心函数，用于创建响应式的副作用。它会自动追踪其内部回调函数中使用的任何响应式数据，并在这些数据变化时重新运行该回调函数。这使得 <code>watchEffect</code> 在处理响应式数据的副作用时非常方便，无需显示指定依赖项，Vue 会自动追踪依赖并在变化时执行回调。</p><h4 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { watchEffect } from &#39;vue&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>watchEffect(callback);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>callback</code>: 是一个函数，用于定义响应式的副作用。该函数会立即执行一次，并自动追踪其内部使用的响应式数据。</p><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><ul><li><strong>自动追踪依赖</strong>：<code>watchEffect</code> 内部的回调函数会自动追踪其使用的响应式数据，无需手动指定依赖项。</li><li><strong>立即执行</strong>：<code>watchEffect</code> 在创建时会立即执行一次其回调函数。</li><li><strong>动态更新</strong>：当回调函数中使用的响应式数据发生变化时，<code>watchEffect</code> 会重新执行回调函数。</li><li><strong>清理函数</strong>：<code>watchEffect</code> 返回一个函数，用于停止追踪并清理副作用。当组件销毁时，Vue 会自动调用该清理函数，以避免内存泄漏。</li></ul><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref, watchEffect } from &#39;vue&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const stop = watchEffect(() =&gt; {</span></span>
<span class="line"><span>  console.log(\`count 的值为: \${count.value}\`);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>  count.value++;</span></span>
<span class="line"><span>}, 1000);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 停止追踪副作用</span></span>
<span class="line"><span>stop();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个响应式的 <code>count</code> 变量，并使用 <code>watchEffect</code> 来追踪其变化。回调函数中打印了 <code>count</code> 的当前值。当 <code>count</code> 变化时，会重新执行回调函数。最后，我们调用 <code>stop</code> 函数停止追踪副作用。</p><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景：</span></a></h3><ul><li><strong>数据侦听</strong>：当需要在数据变化时执行一些逻辑时，<code>watchEffect</code> 是一个很好的选择，尤其是在不需要精确指定依赖项的情况下。</li><li><strong>副作用处理</strong>：<code>watchEffect</code> 通常用于处理响应式数据的副作用，例如数据更新后的界面更新、发送网络请求等。</li><li><strong>调试和日志</strong>：<code>watchEffect</code> 可以用于在开发过程中快速检查响应式数据的变化情况，帮助调试和排除问题。</li></ul><h3 id="watch-和-watcheffect-的基本区别" tabindex="-1"><a class="header-anchor" href="#watch-和-watcheffect-的基本区别"><span><code>watch</code> 和 <code>watchEffect</code> 的基本区别：</span></a></h3><ul><li><p><strong><code>watch</code></strong>：</p><ul><li>是一个函数，接收两个参数：要监视的数据和回调函数。</li><li>需要明确指定要监视的数据，并在回调函数中手动处理数据的变化。</li><li>可以监视多个数据，并可以根据需要进行停止或重新启动监视。</li></ul></li><li><p><strong><code>watchEffect</code></strong>：</p><ul><li>是一个函数，接收一个回调函数作为参数。</li><li>自动地追踪其依赖关系，并在依赖的任何数据发生变化时执行回调函数。</li><li>通常用于处理响应式数据的副作用，无需显式指定依赖项。</li></ul></li></ul><p>结语</p><p>======</p><h3 id="watch-和-watcheffect-的比较" tabindex="-1"><a class="header-anchor" href="#watch-和-watcheffect-的比较"><span><code>watch</code> 和 <code>watchEffect</code> 的比较：</span></a></h3><ul><li><p><strong>精确性</strong>：</p><ul><li><code>watch</code> 允许您精确地指定要监视的数据，并且只有当这些数据变化时才会执行回调函数，因此更适用于需要针对特定数据进行逻辑处理的情况。</li><li><code>watchEffect</code> 自动追踪其内部回调函数中使用的任何响应式数据，并在这些数据变化时执行该回调函数。这意味着它更适合于无需指定特定依赖项的副作用处理。</li></ul></li><li><p><strong>语法简洁性</strong>：</p><ul><li><code>watchEffect</code> 的语法更加简洁，只需要传递一个回调函数即可，而不需要明确指定要监视的数据，这使得它更容易编写和维护。</li><li><code>watch</code> 需要显式指定要监视的数据，使得代码稍微冗长一些，但也更加明确。</li></ul></li><li><p><strong>动态性</strong>：</p><ul><li><code>watch</code> 允许在运行时动态地添加或移除监视，这在某些情况下可能是必要的。</li><li><code>watchEffect</code> 则是一次性地设置，无法在运行时停止或重新启动，它会一直追踪其依赖项直到组件卸载。</li></ul></li></ul><h6 id="下面是一个示例代码-展示了如何使用-watch-进行监听、停止监听和重新开始监听" tabindex="-1"><a class="header-anchor" href="#下面是一个示例代码-展示了如何使用-watch-进行监听、停止监听和重新开始监听"><span>下面是一个示例代码，展示了如何使用 watch 进行监听、停止监听和重新开始监听：</span></a></h6><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref, watch } from &#39;vue&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export default {</span></span>
<span class="line"><span>  setup() {</span></span>
<span class="line"><span>    const myValue = ref(0);</span></span>
<span class="line"><span>    let stopWatch;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 开始监听</span></span>
<span class="line"><span>    stopWatch = watch(</span></span>
<span class="line"><span>      myValue,</span></span>
<span class="line"><span>      (newValue, oldValue) =&gt; {</span></span>
<span class="line"><span>        console.log(\`Value changed from \${oldValue} to \${newValue}\`);</span></span>
<span class="line"><span>      },</span></span>
<span class="line"><span>      {</span></span>
<span class="line"><span>        immediate: true, // 立即执行一次</span></span>
<span class="line"><span>        deep: true // 监听对象内部属性的变化</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 停止监听</span></span>
<span class="line"><span>    const stopListening = () =&gt; {</span></span>
<span class="line"><span>      if (stopWatch) {</span></span>
<span class="line"><span>        stopWatch();</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 重新开始监听</span></span>
<span class="line"><span>    const restartListening = () =&gt; {</span></span>
<span class="line"><span>      if (stopWatch) {</span></span>
<span class="line"><span>        // 确保先停止之前的监听</span></span>
<span class="line"><span>        stopWatch();</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>      // 重新设置监听</span></span>
<span class="line"><span>      stopWatch = watch(</span></span>
<span class="line"><span>        myValue,</span></span>
<span class="line"><span>        (newValue, oldValue) =&gt; {</span></span>
<span class="line"><span>          console.log(\`Value changed from \${oldValue} to \${newValue}\`);</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>          immediate: true,</span></span>
<span class="line"><span>          deep: true</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 返回需要在模板中使用的数据和函数</span></span>
<span class="line"><span>    return {</span></span>
<span class="line"><span>      myValue,</span></span>
<span class="line"><span>      stopListening,</span></span>
<span class="line"><span>      restartListening</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p><code>watch</code> 和 <code>watchEffect</code> 是 Vue 3 提供的两种用于监视数据变化的重要工具。它们分别适用于不同的场景和需求。<code>watch</code> 更适合需要精确控制的情况，而 <code>watchEffect</code> 更适合处理响应式数据的副作用。通过合理选择和使用这两种方法，您可以更有效地管理 Vue 应用程序的状态和逻辑。</p>`,32),l=[c];function t(p,d){return s(),n("div",null,l)}const h=a(i,[["render",t],["__file","深入理解watch和watchEffect的区别与应用.html.vue"]]),u=JSON.parse('{"path":"/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3watch%E5%92%8CwatchEffect%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8.html","title":"深入理解watch和watchEffect的区别与应用.md","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-02-11T00:00:00.000Z","category":["面试"],"tag":["watch","watchEffect","vue"],"description":"深入理解watch和watchEffect的区别与应用.md ====== 在 Vue.js 中，除了可以使用watch方法监视数据变化，其实还有一种名为watchEffect的方法同样可以帮助我们监视数据变化并执行相应操作。对于watch和watchEffect两种方法来说，虽然它们功能上有着相似之处，但是它们之间有一些重要的区别。理解它们的不同之处...","head":[["meta",{"property":"og:url","content":"https://github.com/tommmmya/Tommya-Blog/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3watch%E5%92%8CwatchEffect%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Tommya 个人博客"}],["meta",{"property":"og:title","content":"深入理解watch和watchEffect的区别与应用.md"}],["meta",{"property":"og:description","content":"深入理解watch和watchEffect的区别与应用.md ====== 在 Vue.js 中，除了可以使用watch方法监视数据变化，其实还有一种名为watchEffect的方法同样可以帮助我们监视数据变化并执行相应操作。对于watch和watchEffect两种方法来说，虽然它们功能上有着相似之处，但是它们之间有一些重要的区别。理解它们的不同之处..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-04T10:58:22.000Z"}],["meta",{"property":"article:author","content":"Mr.Tommya"}],["meta",{"property":"article:tag","content":"watch"}],["meta",{"property":"article:tag","content":"watchEffect"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:published_time","content":"2024-02-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-04T10:58:22.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入理解watch和watchEffect的区别与应用.md\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-11T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-04T10:58:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Tommya\\",\\"url\\":\\"https://github.com/tommmmya\\"}]}"]]},"headers":[{"level":2,"title":"watch","slug":"watch","link":"#watch","children":[]},{"level":2,"title":"watchEffect","slug":"watcheffect","link":"#watcheffect","children":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"特性","slug":"特性","link":"#特性","children":[]},{"level":3,"title":"使用场景：","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"watch 和 watchEffect 的基本区别：","slug":"watch-和-watcheffect-的基本区别","link":"#watch-和-watcheffect-的基本区别","children":[]},{"level":3,"title":"watch 和 watchEffect 的比较：","slug":"watch-和-watcheffect-的比较","link":"#watch-和-watcheffect-的比较","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1728989573000,"updatedTime":1730717902000,"contributors":[{"name":"tangmao02","email":"tangmao02@meituan.com","commits":3}]},"readingTime":{"minutes":5.08,"words":1525},"filePathRelative":"study/2.深入必备/深入理解watch和watchEffect的区别与应用.md","localizedDate":"2024年2月11日","excerpt":"\\n<p>======</p>\\n<p>在 Vue.js 中，除了可以使用<code>watch</code>方法监视数据变化，其实还有一种名为<code>watchEffect</code>的方法同样可以帮助我们监视数据变化并执行相应操作。对于<code>watch</code>和<code>watchEffect</code>两种方法来说，虽然它们功能上有着相似之处，但是它们之间有一些重要的区别。理解它们的不同之处对于有效地使用 Vue 3 来管理应用程序状态至关重要。</p>\\n<h2><code>watch</code></h2>\\n<p>对于<code>watch</code>方法，我们之前已经详细的介绍过了，这里不再过多赘述。</p>","autoDesc":true}');export{h as comp,u as data};
