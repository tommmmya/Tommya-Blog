import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,d as n}from"./app-jr09F59J.js";const i={},t=n(`<h1 id="使用ref还是reactive" tabindex="-1"><a class="header-anchor" href="#使用ref还是reactive"><span>使用Ref还是Reactive</span></a></h1><p>我喜欢 Vue 3 的 Composition API，它提供了两种方法来为 Vue 组件添加响应式状态：<code>ref</code>和<code>reactive</code>。当你使用<code>ref</code>时到处使用<code>.value</code>是很麻烦的，但当你用<code>reactive</code>创建的响应式对象进行重构时，也很容易丢失响应性。 在这篇文章中，我将阐释你如何来选择<code>reactive</code>以及<code>ref</code>。</p><p>一句话总结：默认情况下使用<code>ref</code>，当你需要对变量分组时使用<code>reactive</code>。</p><h2 id="vue3-的响应式" tabindex="-1"><a class="header-anchor" href="#vue3-的响应式"><span>Vue3 的响应式</span></a></h2><p>在我解释<code>ref</code>和<code>reactive</code>之前，你应该了解 Vue3 响应式系统的基本知识。</p><p>如果你已经掌握了 Vue3 响应式系统是如何工作的，你可以跳过本小节。</p><p>很不幸，JavaScript 默认情况下并不是响应式的。让我们看看下面代码示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let price = 10.0</span></span>
<span class="line"><span>const quantity = 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const total = price * quantity</span></span>
<span class="line"><span>console.log(total) // 20</span></span>
<span class="line"><span></span></span>
<span class="line"><span>price = 20.0</span></span>
<span class="line"><span>console.log(total) // ⚠️ total is still 20</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在响应式系统中，我们期望每当<code>price</code>或者<code>quantity</code>改变时，<code>total</code>就会被更新。但是 JavaScript 通常情况下并不会像预期的这样生效。</p><p>你也许会嘀咕，为什么 Vue 需要响应式系统？答案很简单：Vue 组件的状态由响应式 JavaScript 对象组成。当你修改这些对象时，视图或者依赖的响应式对象就会更新。</p><p>因此，Vue 框架必须实现另一种机制来跟踪局部变量的读和写，它是通过<strong>拦截对象属性的读写</strong>来实现的。这样一来，Vue 就可以跟踪一个响应式对象的属性访问以及更改。</p><p>由于浏览器的限制，Vue 2 专门使用 getters/setters 来拦截属性。Vue 3 对响应式对象使用 Proxy，对<code>ref</code>使用 getters/setters。下面的伪代码展示了属性拦截的基本原理；它解释了核心概念，并忽略了许多细节和边缘情况：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function reactive(obj) {</span></span>
<span class="line"><span>  return new Proxy(obj, {</span></span>
<span class="line"><span>    get(target, key) {</span></span>
<span class="line"><span>      track(target, key)</span></span>
<span class="line"><span>      return target[key]</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    set(target, key, value) {</span></span>
<span class="line"><span>      target[key] = value</span></span>
<span class="line"><span>      trigger(target, key)</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  })</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>proxy</code>的<code>get</code>和<code>set</code>方法通常被称为代理陷阱。</p><p>这里强烈建议阅读官方文档来查看有关 Vue 响应式系统的更多细节。</p><h2 id="reactive" tabindex="-1"><a class="header-anchor" href="#reactive"><span>reactive()</span></a></h2><p>现在，让我们来分析下，你如何使用 Vue3 的<code>reactive()</code>函数来声明一个响应式状态：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { reactive } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const state = reactive({ count: 0 })</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该状态默认是深度响应式的。如果你修改了嵌套的数组或对象，这些更改都会被 vue 检测到：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { reactive } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const state = reactive({</span></span>
<span class="line"><span>  count: 0,</span></span>
<span class="line"><span>  nested: { count: 0 },</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>watch(state, () =&gt; console.log(state))</span></span>
<span class="line"><span>// &quot;{ count: 0, nested: { count: 0 } }&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const incrementNestedCount = () =&gt; {</span></span>
<span class="line"><span>  state.nested.count += 1</span></span>
<span class="line"><span>  // Triggers watcher -&gt; &quot;{ count: 0, nested: { count: 1 } }&quot;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="限制" tabindex="-1"><a class="header-anchor" href="#限制"><span>限制</span></a></h3><p><code>reactive()</code>API 有两个限制：</p><p>第一个限制是，它只适用于对象类型，比如对象、数组和集合类型，如<code>Map</code>和<code>Set</code>。它不适用于原始类型，比如<code>string</code>、<code>number</code>或<code>boolean</code>。</p><p>第二个限制是，从<code>reactive()</code>返回的代理对象与原始对象是不一样的。用<code>===</code>操作符进行比较会返回<code>false</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const plainJsObject = {}</span></span>
<span class="line"><span>const proxy = reactive(plainJsObject)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// proxy is NOT equal to the original plain JS object.</span></span>
<span class="line"><span>console.log(proxy === plainJsObject) // false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你必须始终保持对响应式对象的相同引用，否则，Vue 无法跟踪对象的属性。如果你试图将一个响应式对象的属性解构为局部变量，你可能会遇到这个问题：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = reactive({</span></span>
<span class="line"><span>  count: 0,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ⚠️ count is now a local variable disconnected from state.count</span></span>
<span class="line"><span>let { count } = state</span></span>
<span class="line"><span></span></span>
<span class="line"><span>count += 1 // ⚠️ Does not affect original state</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>幸运的是，你可以首先使用<code>toRefs</code>将对象的所有属性转换为响应式的，然后你可以解构对象而不丢失响应：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>let state = reactive({</span></span>
<span class="line"><span>  count: 0,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// count is a ref, maintaining reactivity</span></span>
<span class="line"><span>const { count } = toRefs(state)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你试图重新赋值<code>reactive</code>的值，也会发生类似的问题。如果你 &quot;替换&quot; 一个响应式对象，新的对象会覆盖对原始对象的引用，并且响应式连接会丢失：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = reactive({</span></span>
<span class="line"><span>  count: 0,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>watch(state, () =&gt; console.log(state), { deep: true })</span></span>
<span class="line"><span>// &quot;{ count: 0 }&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ⚠️ The above reference ({ count: 0 }) is no longer being tracked (reactivity connection is lost!)</span></span>
<span class="line"><span>state = reactive({</span></span>
<span class="line"><span>  count: 10,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>// ⚠️ The watcher doesn&#39;t fire</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们传递一个属性到函数中，响应式连接也会丢失：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = reactive({</span></span>
<span class="line"><span>  count: 0,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const useFoo = (count) =&gt; {</span></span>
<span class="line"><span>  // ⚠️ Here count is a plain number and the useFoo composable</span></span>
<span class="line"><span>  // cannot track changes to state.count</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>useFoo(state.count)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span>ref()</span></a></h2><p>Vue 提供了<code>ref()</code>函数来解决<code>reactive()</code>的限制。</p><p><code>ref()</code>并不局限于对象类型，而是可以容纳任何值类型：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span>const state = ref({ count: 0 })</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了读写通过<code>ref()</code>创建的响应式变量，你需要通过<code>.value</code>属性来访问：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span>const state = ref({ count: 0 })</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(count) // { value: 0 }</span></span>
<span class="line"><span>console.log(count.value) // 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>count.value++</span></span>
<span class="line"><span>console.log(count.value) // 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>state.value.count = 1</span></span>
<span class="line"><span>console.log(state.value) // { count: 1 }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会问自己，<code>ref()</code>如何能容纳原始类型，因为我们刚刚了解到 Vue 需要一个对象才能触发 get/set 代理陷阱。下面的伪代码展示了<code>ref()</code>背后的简化逻辑：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>function ref(value) {</span></span>
<span class="line"><span>  const refObject = {</span></span>
<span class="line"><span>    get value() {</span></span>
<span class="line"><span>      track(refObject, &#39;value&#39;)</span></span>
<span class="line"><span>      return value</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    set value(newValue) {</span></span>
<span class="line"><span>      value = newValue</span></span>
<span class="line"><span>      trigger(refObject, &#39;value&#39;)</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return refObject</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当拥有对象类型时，<code>ref</code>自动用<code>reactive()</code>转换其<code>.value</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ref({}) ~= ref(reactive({}))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果你想深入了解，可以在源码中查看<code>ref()</code>的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fcore%2Fblob%2Fmain%2Fpackages%2Freactivity%2Fsrc%2Fref.ts" title="https://github.com/vuejs/core/blob/main/packages/reactivity/src/ref.ts" target="_blank" rel="noopener noreferrer">实现</a>。</p><p>不幸的是，也不能对用<code>ref()</code>创建的响应式对象进行解构。这也会导致响应式丢失：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const countValue = count.value // ⚠️ disconnects reactivity</span></span>
<span class="line"><span>const { value: countDestructured } = count // ⚠️ disconnects reactivity</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，如果将<code>ref</code>分组在一个普通的 JavaScript 对象中，就不会丢失响应式：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = {</span></span>
<span class="line"><span>  count: ref(1),</span></span>
<span class="line"><span>  name: ref(&#39;Michael&#39;),</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const { count, name } = state // still reactive</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ref</code>也可以被传递到函数中而不丢失响应式。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = {</span></span>
<span class="line"><span>  count: ref(1),</span></span>
<span class="line"><span>  name: ref(&#39;Michael&#39;),</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const useFoo = (count) =&gt; {</span></span>
<span class="line"><span>  /**</span></span>
<span class="line"><span>   * The function receives a ref</span></span>
<span class="line"><span>   * It needs to access the value via .value but it</span></span>
<span class="line"><span>   * will retain the reactivity connection</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>useFoo(state.count)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种能力相当重要，因为它在将逻辑提取到组合式函数中时经常被使用。 一个包含对象值的<code>ref</code>可以响应式地替换整个对象：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>const state = {</span></span>
<span class="line"><span>  count: 1,</span></span>
<span class="line"><span>  name: &#39;Michael&#39;,</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Still reactive</span></span>
<span class="line"><span>state.value = {</span></span>
<span class="line"><span>  count: 2,</span></span>
<span class="line"><span>  name: &#39;Chris&#39;,</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="解包-refs" tabindex="-1"><a class="header-anchor" href="#解包-refs"><span>解包 refs()</span></a></h3><p>在使用<code>ref</code>时到处使用<code>.value</code>可能很麻烦，但我们可以使用一些辅助函数。</p><p><strong>unref 实用函数</strong></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fvuejs.org%2Fapi%2Freactivity-utilities.html%23unref" title="https://vuejs.org/api/reactivity-utilities.html#unref" target="_blank" rel="noopener noreferrer">unref()</a> 是一个便捷的实用函数，在你的值可能是一个<code>ref</code>的情况下特别有用。在一个非<code>ref</code>上调用<code>.value</code>会抛出一个运行时错误，<code>unref()</code>在这种情况下就很有用：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { ref, unref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const unwrappedCount = unref(count)</span></span>
<span class="line"><span>// same as isRef(count) ? count.value : count\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code>unref()</code>的参数是一个<code>ref</code>，就会返回其内部值。否则就返回参数本身。这是的<code>val = isRef(val) ? val.value : val</code>语法糖。</p><p><strong>模板解包</strong></p><p>当你在模板上调用<code>ref</code>时，Vue 会自动使用<code>unref()</code>进行解包。这样，你永远不需要在模板中使用<code>.value</code>进行访问：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;script setup&gt;</span></span>
<span class="line"><span>import { ref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span>&lt;/script&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;template&gt;</span></span>
<span class="line"><span>  &lt;span&gt;</span></span>
<span class="line"><span>    &lt;!-- no .value needed --&gt;</span></span>
<span class="line"><span>    {{ count }}</span></span>
<span class="line"><span>  &lt;/span&gt;</span></span>
<span class="line"><span>&lt;/template&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只在<code>ref</code>是模板中的顶级属性时才生效。</p><p><strong>侦听器</strong></p><p>我们可以直接传递一个<code>ref</code>作为侦听器的依赖：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>import { watch, ref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const count = ref(0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Vue automatically unwraps this ref for us</span></span>
<span class="line"><span>watch(count, (newCount) =&gt; console.log(newCount))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Volar</strong></p><p>如果你正在使用 VS Code，你可以通过配置<a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer"></a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">相应的 JSON 设置：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&quot;volar.autoCompleteRefs&quot;: true]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为了减少 CPU 的使用，这个功能默认是禁用的。</p><h2 id="比较" tabindex="-1"><a class="header-anchor" href="#比较"><span><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">比较</a></span></a></h2><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">让我们总结一下<code>reactive</code>和<code>ref</code>之间的区别：</a></p><table><thead><tr><th>reactive</th><th>ref</th></tr></thead><tbody><tr><td>👎 只对对象类型起作用</td><td>👍对任何类型起作用</td></tr><tr><td>👍在<code>&lt;script&gt;</code>和<code>&lt;template&gt;</code>中访问值没有区别</td><td>👎访问<code>&lt;script&gt;</code>和<code>&lt;template&gt;</code>中的值的行为不同</td></tr><tr><td>👎重新赋值一个新的对象会 &quot;断开&quot; 响应式</td><td>👍对象引用可以被重新赋值</td></tr><tr><td>属性可以在没有<code>.value</code>的情况下被访问</td><td>需要使用<code>.value</code>来访问属性</td></tr><tr><td></td><td>👍引用可以通过函数进行传递</td></tr><tr><td>👎解构的值不是响应式的</td><td></td></tr><tr><td>👍与 Vue2 的 data 对象相似</td><td></td></tr></tbody></table><h2 id="我的观点" tabindex="-1"><a class="header-anchor" href="#我的观点"><span><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">我的观点</a></span></a></h2><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">我最喜欢<code>ref</code>的地方是，如果你看到它的属性是通过<code>.value</code>访问的，你就知道它是一个响应式的值。如果你使用一个用<code>reactive</code>创建的对象，就不那么清楚了：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[anyObject.property = &#39;new&#39; // anyObject could be a plain JS object or a reactive object</span></span>
<span class="line"><span></span></span>
<span class="line"><span>anyRef.value = &#39;new&#39; // likely a ref](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar &quot;https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">这个假设只有在你对<code>ref</code>有基本的了解，并且知道你用<code>.value</code>来读取响应式变量时才有效。</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">如果你在使用<code>ref</code>，你应该尽量避免使用具有<code>value</code>属性的非响应式对象：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[const dataFromApi = { value: &#39;abc&#39;, name: &#39;Test&#39; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const reactiveData = ref(dataFromApi)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const valueFromApi = reactiveData.value.value // 🤮](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar &quot;https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">如果你刚开始使用 Composition API，<code>reactive</code>可能更直观，如果你试图将一个组件从 Options API 迁移到 Composition API，它是相当方便的。<code>reactive</code>的工作原理与<code>data</code>内的响应式属性非常相似：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&lt;script&gt;</span></span>
<span class="line"><span>export default {</span></span>
<span class="line"><span>  data() {</span></span>
<span class="line"><span>    count: 0,</span></span>
<span class="line"><span>    name: &#39;MyCounter&#39;</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  methods: {</span></span>
<span class="line"><span>    increment() {</span></span>
<span class="line"><span>      this.count += 1;</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>&lt;/script&gt;](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar &quot;https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">你可以简单地将<code>data</code>中的所有内容复制到<code>reactive</code>中，然后将这个组件迁移到 Composition API 中：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[&lt;script setup&gt;</span></span>
<span class="line"><span>setup() {</span></span>
<span class="line"><span>  // Equivalent to &quot;data&quot; in Options API</span></span>
<span class="line"><span>  const state = reactive({</span></span>
<span class="line"><span>    count: 0,</span></span>
<span class="line"><span>    name: &#39;MyCounter&#39;</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span>  const {count, name} = toRefs(statee)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  // Equivalent to &quot;methods&quot; in Options API</span></span>
<span class="line"><span>  increment(username) {</span></span>
<span class="line"><span>    state.count += 1;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&lt;/script&gt;](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar &quot;https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="比较-ref-和-reactive" tabindex="-1"><a class="header-anchor" href="#比较-ref-和-reactive"><span><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">比较 ref 和 reactive</a></span></a></h3><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">一个推荐的模式是在一个<code>reactive</code>对象中对<code>ref</code>分组：</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[const loading = ref(true)</span></span>
<span class="line"><span>const error = ref(null)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const state = reactive({</span></span>
<span class="line"><span>  loading,</span></span>
<span class="line"><span>  error,</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// You can watch the reactive object...</span></span>
<span class="line"><span>watchEffect(() =&gt; console.log(state.loading))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// ...and the ref directly</span></span>
<span class="line"><span>watch(loading, () =&gt; console.log(&#39;loading has changed&#39;))</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(() =&gt; {</span></span>
<span class="line"><span>  loading.value = false</span></span>
<span class="line"><span>  // Triggers both watchers</span></span>
<span class="line"><span>}, 500)](https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar &quot;https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">如果你不需要<code>state</code>对象本身的响应式，你可以在一个普通的 JavaScript 对象中进行分组。 对 <code>refs</code> 进行分组的结果是一个单一的对象，它更容易处理，并使你的代码保持有序。你可以看到分组后的 <code>refs</code> 属于一起，并且是相关的。</a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer"></a></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3DVue.volar" title="https://marketplace.visualstudio.com/items?item&gt;Volar&lt;/a&gt; 扩展来自动地添加&lt;code&gt;.value&lt;/code&gt;到&lt;code&gt;ref&lt;/code&gt;上。你可以在&lt;code&gt;Volar: Auto Complete Refs&lt;/code&gt;设置中开启：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=" target="_blank" rel="noopener noreferrer">这种模式也被用于像</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fvuelidate.js.org%2F" title="https://vuelidate.js.org/" target="_blank" rel="noopener noreferrer">Vuelidate</a> 这样的库中，他们使用<code>reactive()</code>来设置验证的状态。</p><p>总结起来，社区中的最佳实践是默认使用<code>ref</code>，在需要分组的时候使用<code>reactive</code>。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>那么，你究竟该使用<code>ref</code>还是<code>reactive</code>？</p><p>我的建议是默认使用<code>ref</code>，当你需要分组时使用<code>reactive</code>。Vue 社区也有同样的观点，但如果你决定默认使用<code>reactive</code>，也完全没有问题。</p><p><code>ref</code>和<code>reactive</code>都是在 Vue 3 中创建响应式变量的强大工具。你甚至可以在没有任何技术缺陷的情况下同时使用它们。只要你选择你喜欢的那一个，并尽量在写代码时保持一致就可以了！</p><p>以上就是本文的全部内容，如果对你有所帮助，欢迎点赞、收藏、转发~</p>`,95),l=[t];function p(c,d){return a(),s("div",null,l)}const v=e(i,[["render",p],["__file","使用Ref还是Reactive.html.vue"]]),u=JSON.parse('{"path":"/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/%E4%BD%BF%E7%94%A8Ref%E8%BF%98%E6%98%AFReactive.html","title":"使用Ref还是Reactive","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-02-22T00:00:00.000Z","category":["面试"],"tag":["Ref","reactive","vue"],"description":"使用Ref还是Reactive 我喜欢 Vue 3 的 Composition API，它提供了两种方法来为 Vue 组件添加响应式状态：ref和reactive。当你使用ref时到处使用.value是很麻烦的，但当你用reactive创建的响应式对象进行重构时，也很容易丢失响应性。 在这篇文章中，我将阐释你如何来选择reactive以及ref。 一句...","head":[["meta",{"property":"og:url","content":"https://github.com/tommmmya/Tommya-Blog/study/2.%E6%B7%B1%E5%85%A5%E5%BF%85%E5%A4%87/%E4%BD%BF%E7%94%A8Ref%E8%BF%98%E6%98%AFReactive.html"}],["meta",{"property":"og:site_name","content":"Tommya 个人博客"}],["meta",{"property":"og:title","content":"使用Ref还是Reactive"}],["meta",{"property":"og:description","content":"使用Ref还是Reactive 我喜欢 Vue 3 的 Composition API，它提供了两种方法来为 Vue 组件添加响应式状态：ref和reactive。当你使用ref时到处使用.value是很麻烦的，但当你用reactive创建的响应式对象进行重构时，也很容易丢失响应性。 在这篇文章中，我将阐释你如何来选择reactive以及ref。 一句..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-29T07:56:04.000Z"}],["meta",{"property":"article:author","content":"Mr.Tommya"}],["meta",{"property":"article:tag","content":"Ref"}],["meta",{"property":"article:tag","content":"reactive"}],["meta",{"property":"article:tag","content":"vue"}],["meta",{"property":"article:published_time","content":"2024-02-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-10-29T07:56:04.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用Ref还是Reactive\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-10-29T07:56:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Tommya\\",\\"url\\":\\"https://github.com/tommmmya\\"}]}"]]},"headers":[{"level":2,"title":"Vue3 的响应式","slug":"vue3-的响应式","link":"#vue3-的响应式","children":[]},{"level":2,"title":"reactive()","slug":"reactive","link":"#reactive","children":[{"level":3,"title":"限制","slug":"限制","link":"#限制","children":[]}]},{"level":2,"title":"ref()","slug":"ref","link":"#ref","children":[{"level":3,"title":"解包 refs()","slug":"解包-refs","link":"#解包-refs","children":[]}]},{"level":2,"title":"比较","slug":"比较","link":"#比较","children":[]},{"level":2,"title":"我的观点","slug":"我的观点","link":"#我的观点","children":[{"level":3,"title":"比较 ref 和 reactive","slug":"比较-ref-和-reactive","link":"#比较-ref-和-reactive","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1728989573000,"updatedTime":1730188564000,"contributors":[{"name":"tangmao02","email":"tangmao02@meituan.com","commits":2}]},"readingTime":{"minutes":12.71,"words":3812},"filePathRelative":"study/2.深入必备/使用Ref还是Reactive.md","localizedDate":"2024年2月22日","excerpt":"\\n<p>我喜欢 Vue 3 的 Composition API，它提供了两种方法来为 Vue 组件添加响应式状态：<code>ref</code>和<code>reactive</code>。当你使用<code>ref</code>时到处使用<code>.value</code>是很麻烦的，但当你用<code>reactive</code>创建的响应式对象进行重构时，也很容易丢失响应性。 在这篇文章中，我将阐释你如何来选择<code>reactive</code>以及<code>ref</code>。</p>\\n<p>一句话总结：默认情况下使用<code>ref</code>，当你需要对变量分组时使用<code>reactive</code>。</p>","autoDesc":true}');export{v as comp,u as data};
