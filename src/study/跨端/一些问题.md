---
icon: pen-to-square
date: 2022-01-11
category:
  - 跨端
tag:
  - react nativ
  - 跨端
---
# RN和Kotlin语言隔离怎么解决
React Native (RN) 使用 JavaScript 来编写应用逻辑，但它能够调用 Android 端的原生代码（包括 Kotlin 编写的代码）。这是通过 React Native 的桥接（Bridge）机制实现的。这个机制允许 JavaScript 与原生代码进行通信，互相调用函数。以下是这个过程的详细解释，包括相关的原理和示例代码。

### 1. **React Native 的桥接机制**

React Native 中，JavaScript 和原生代码（无论是 Java、Kotlin 还是 Objective-C、Swift）之间的通信是通过一种称为 “Bridge” 的机制来实现的。Bridge 的核心工作是将 JavaScript 中的数据和操作转换为原生代码能够理解的形式，反之亦然。

#### 1.1 JavaScript 调用原生代码

当 JavaScript 代码需要调用原生功能（比如摄像头、GPS 等），它会通过 Bridge 发送一个请求。这些请求会被传递给原生代码中的一个模块，该模块通常用 Kotlin 或 Java 编写。

#### 1.2 原生代码调用 JavaScript

原生代码也可以通过 Bridge 发送事件或数据回到 JavaScript 层，这样 JavaScript 可以处理原生事件（例如按钮点击、传感器数据等）。

### 2. **React Native 调用 Kotlin 原生代码的实现**

#### 2.1 创建 Kotlin 原生模块

首先，我们需要在 Android 项目中创建一个 Kotlin 类，并使其成为一个可以被 React Native 调用的模块。

```
kotlin复制代码package com.example.myapp

import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.Promise

class MyKotlinModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {

    override fun getName(): String {
        return "MyKotlinModule"
    }

    @ReactMethod
    fun sayHello(name: String, promise: Promise) {
        val greeting = "Hello, $name!"
        promise.resolve(greeting)
    }
}
```

在这个例子中，我们创建了一个名为 `MyKotlinModule` 的类，它继承了 `ReactContextBaseJavaModule`，这是创建原生模块的标准做法。我们在这个模块中定义了一个 `sayHello` 方法，该方法接收一个字符串并返回一个包含问候语的字符串。

#### 2.2 注册 Kotlin 模块

接下来，我们需要在应用的 `ReactPackage` 中注册这个模块，以便 React Native 可以找到并使用它。

```
kotlin复制代码package com.example.myapp

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class MyAppPackage : ReactPackage {

    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(MyKotlinModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}
```

在 `MyAppPackage` 中，我们通过 `createNativeModules` 方法将 `MyKotlinModule` 模块注册到 React Native 的模块列表中。

#### 2.3 配置 `MainApplication`

在 Android 项目的 `MainApplication` 类中，我们需要确保 `MyAppPackage` 被添加到应用的包列表中：

```
kotlin复制代码package com.example.myapp

import android.app.Application
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.shell.MainReactPackage
import java.util.Arrays

class MainApplication : Application(), ReactApplication {

    private val mReactNativeHost: ReactNativeHost = object : ReactNativeHost(this) {
        override fun getPackages(): List<ReactPackage> {
            return Arrays.asList(
                MainReactPackage(),
                MyAppPackage()  // 添加我们自定义的包
            )
        }

        override fun getJSMainModuleName(): String {
            return "index"
        }
    }

    override fun getReactNativeHost(): ReactNativeHost {
        return mReactNativeHost
    }
}
```

#### 2.4 在 JavaScript 中调用 Kotlin 方法

最后，在 JavaScript 中，我们可以像使用其他 JavaScript 函数一样调用这个原生模块。

```
javascript复制代码import { NativeModules } from 'react-native';

const { MyKotlinModule } = NativeModules;

MyKotlinModule.sayHello('React Native User')
  .then(greeting => {
    console.log(greeting);  // 输出：Hello, React Native User!
  })
  .catch(error => {
    console.error(error);
  });
```

在这里，我们导入了 `NativeModules`，并通过它访问 `MyKotlinModule`。我们调用 `sayHello` 方法，并处理其返回的 Promise。

### 3. **底层原理分析**

- **Bridge 通信**：当 JavaScript 调用 `MyKotlinModule.sayHello` 方法时，React Native 的 Bridge 将调用传递到原生层。Bridge 将 JavaScript 的调用参数（如字符串 `React Native User`）转换为原生格式，并在 Kotlin 代码中执行该方法。
- **异步执行**：React Native 的通信通常是异步的，JavaScript 线程不会被阻塞。Kotlin 的 `Promise` 对象用于处理方法执行的结果，并将结果传回 JavaScript 层。
- **数据传输**：数据在 JavaScript 和原生层之间通过序列化和反序列化进行传输。React Native 使用的 JavaScriptCore 或 Hermes 引擎负责处理 JavaScript 对象的序列化，而原生层则根据需要将其解析为 Kotlin 或 Java 对象。

### 4. **总结**

通过 React Native 的桥接机制，JavaScript 可以轻松调用 Kotlin 编写的原生代码，并且这两者之间的通信是通过异步的方式进行的，以确保应用的流畅性。React Native 框架通过这个桥接层，实现了跨平台的能力，让开发者在无需深入了解每个平台细节的情况下，也能高效地利用原生平台的强大功能。用原生平台的强大功能。